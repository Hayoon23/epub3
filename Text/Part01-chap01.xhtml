<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
  <title>1212</title>
  <link href="../Styles/PY_Ebook_Basic_Style.css" type="text/css" rel="stylesheet"/>
</head>

<body>
  <div class="box1 bg1">
    <h2 class="txt2"><span class="dgray1">0</span><span class="dwhite">1 협동로봇의 이해</span></h2>
  </div>

  <h3 class="section gothic_b f115" id="sigil_toc_id_1"><span class="txtball dwhite">가</span> 로봇의 구성 요소</h3>

  <p class="th4">1) 구성 요소</p>

  <p class="txt indent1">로봇 티칭을 배우기 앞서 먼저 로봇의 구성에 대해서 이야기해 보자. 현재 대부분의 로봇은 로봇팔, 제어장치, 입출력장치의 3개의 장치 구성을 이루고 있다. 기업마다 이름이 조금씩 다른데, 유니버설 로봇<span class="bracket">(Universal Robot, UR; 이하 UR)</span>의 경우 &#60;그림 I-3&#62;과 같이 각각 로봇암<span class="bracket">(Robot Arm)</span>, 컨트롤 박스<span class="bracket">(Control Box)</span>, 티치 팬던트<span class="bracket">(Teach Pendent)</span>라고 부른다. 이 세 개의 구성 요소는 컴퓨터 시스템과 비교를 할 수 있다. 로봇암은 모니터, 컨트롤 박스는 컴퓨터 본체, 티치 팬던트를 키보드와 마우스와 매칭된다. 로봇암은 출력 장치로 볼 수 있고, 사용자가 원하는 동작을 실제 수행하는 역할을 한다. 컨트롤 박스는 컴퓨터 본체로 사용자가 원하는 입력을 받아서 적절한 형태의 동작이 이루어질 수 있도록 중간 연산을 하는 역할을 한다. 마지막으로 티치 팬던트의 경우 사용자가 컨트롤 박스에 요구하는 명령을 전달하기 위한 입력 장치로, 산업 환경에서 키보드와 마우스는 먼지, 습도, 충격 등 열악한 산업 환경 조건에서 사용하기에 적합하지 않아 보완 및 설계된 장치라고 생각하면 된다. 형태는 태블릿 PC와 유사한 터치 스크린<span class="bracket">(Touch Screen)</span>을 가진 장치이다. 각 구성 요소에 대해서는 요소별로 뒤에서 더 자세히 설명하도록 하겠다.</p>

  <div class="w80 img_center ">
    <img alt="part01-p020-img" src="../Images/part01-p020-img.jpg"/>
  </div>
  <div class="img_center flex_column">
    <img class="w40 mcenter" alt="part01-p021-img" src="../Images/part01-p021-img.jpg"/> 

    <p class="imgcaption"><span class="gothic_b dblue">&#60;그림 Ⅰ-3&#62;</span> 로봇의 구성 요소</p>
  </div>

  <p class="th4">2) 로봇암</p>

  <p class="txt indent1">로봇암의 경우 팔의 구조를 이루는 기구부 및 각 관절마다 서보 모터<span class="bracket">(Servo Motor)</span> 및 엔코더<span class="bracket">(Encoder)</span>로 구성되어 있다. 서보 모터가 근육의 역할을 담당하고, 엔코더는 모터의 위치정보를 피드백<span class="bracket">(Feedback)</span>한다. 로봇암을 구성하고 있는 모터의 개수가 자유도가 된다. 예를 들자면 UR3 로봇의 경우 총 6개의 서보 모터가 달려있으므로 ‘6 자유도’ 로봇이 된다. 마찬가지로 모터가 5개면 5 자유도, 7개면 7 자유도라고 부른다. 로봇암은 &#60;그림 I-4&#62;와 같이 관절별로 명칭을 가지는데, 각각의 이름은 아래에서부터 베이스<span class="bracket">(Base)</span>, 숄더<span class="bracket">(Shoulder)</span>, 엘보<span class="bracket">(Elbow)</span>, 손목1<span class="bracket">(Wrist1)</span>, 손목2<span class="bracket">(Wrist2)</span>, 손목3<span class="bracket">(Wrist3)</span> 등이다. 특히, 손목1, 2 및 3은 가까운 곳에 붙어서 사람의 손목과 같이 360도 자유로운 회전이 가능하다. 각 모터가 움직일 수 있는 범위의 제한이 다를 수 있다. 예를 들어 UR3의 경우 손목3을 제외한 다른 모터는 ±360도 회전만 허용하지만, 손목3은 무한 회전이 가능하다. 일반적으로 로봇암은 사람의 손에 해당하는 ‘엔드 이펙터<span class="bracket">(End Effector)</span>’를 포함하지 않는다. 여기서 ‘엔드 이펙터’는 손 형태의 그리퍼<span class="bracket">(Gripper)</span>뿐만 아니라 칼, 포크 등 요구 동작에 따라서 다양한 형태가 될 수 있다. 로봇암에는 다양한 ‘엔드 이펙터’를 연결할 수 있는 기구부<span class="bracket">(Tool Flange)</span> 및 제어 신호를 전달하기 위한 커넥터<span class="bracket">(Tool I/O)</span>를 가지고 있다. 앞으로 로봇에 장착하는 ‘엔드 이펙터’를 ‘툴<span class="bracket">(Tool)</span>’이라고 부르겠다. 로봇암에는 서보 모터 제어를 위한 제어 보드 이외에 전원부 및 능동적 연산을 위한 장치는 없다. 이러한 역할은 컨트롤 박스에서 수행한다.</p>

  <div class="w60 img_center">
    <img alt="part01-p022-img" src="../Images/part01-p022-img.jpg"/>
  </div>

  <p class="imgcaption"><span class="gothic_b dblue">&#60;그림 Ⅰ-4&#62;</span> 로봇암의 부위별 명칭</p>

  <p class="th4">3) 컨트롤 박스</p>

  <p class="txt indent1">컨트롤 박스는 말하자면 로봇암을 제어하기 위한 컴퓨터라고 이야기할 수 있다. 로봇별로 차이는 있겠지만 내부에는 저장장치, 연산을 위한 프로세서, USB 연결 포트, 디스플레이 연결 포트, 인터넷 연결 포트 등을 갖추고 있다. 이 컨트롤 박스의 주요 목적은 사용자가 생성한 프로그램 코드에 따라서 로봇암에 필요한 전원 공급 및 제어 신호를 생성하는 것이다. 일반적인 컴퓨터와 다른 점은 내부에 다양한 신호를 직접 연결할 수 있는 접점 I/O들이 있다는 점이다. &#60;그림 I-5&#62;는 UR3e 제품의 내부 모습이다. 우측으로 여러 개의 I/O가 있는데 크게 3개 목적으로 나눌 수 있다. 먼저 노란색은 ‘비상정지’ 등의 안전 목적으로 사용하는 I/O이다. 특히 가장 좌측은 ‘비상정지’ 목적으로만 사용하는 I/O로 다른 용도로의 활용은 불가능하다. 그 우측으로 4줄은 I/O가 있는데, 이것들은 사용자가 프로그램하여 용도를 바꿔 사용할 수 있다. 그 우측으로는 회색의 I/O가 있는데, 디지털 신호를 위한 것들이다. 로봇에서 디지털 신호는 산업 기준에 맞춰서 24V 기준이다. 즉, Low 신호는 ‘0V’, High 신호는 ‘24V’이다. 제일 우측의 녹색 I/O는 아날로그 신호용이며, 10V 입력 범위를 일반적으로 가진다. 다만, 이 부분은 기업별로 차이가 있을 수 있으므로 해당 기업에서 제공하는 매뉴얼을 참조하기 바란다.</p>

  <div class="w80 img_center flex_column">
    <img alt="part01-p023-img" src="../Images/part01-p023-img.jpg"/> 

    <p class="imgcaption"><span class="gothic_b dblue">&#60;그림 Ⅰ-5&#62;</span> 컨트롤 박스 내부 구조</p>
  </div>

  <p class="th4">4) 티치 팬던트</p>

  <p class="txt indent1">&#60;그림 I-6&#62;은 티치 팬던트의 사진이다. 티치 팬던트는 컴퓨터로 치면 ‘키보드와 마우스’에 해당한다. 즉, 프로그래밍 및 로봇제어를 위한 사용자 입출력장치다. 티치 팬던트는 화면 터치 기능이 있는 디스플레이, 전원 버튼, 비상정지 버튼이 있다. 비상정지 버튼은 크고 누르기 쉽게 구현되어 있는데 이는 티칭 도중에 발생하는 돌발 상황에 빠르게 대응하기 위함이다. 그에 비해서 전원 버튼은 작고 누르기 불편하게 구현되어 있다. 이는 오조작을 방지하기 위해서이다. UR 로봇의 경우 티치 팬던트 뒤쪽으로 ‘프리드라이브’ 버튼이 있다. 프리드라이브는 일반적인 산업용 로봇과 협동로봇의 두드러진 차이점 중 하나로 협동로봇은 이 버튼을 이용해서 사용자가 손으로 직접 자유롭게 로봇을 움직일 수 있다. 로봇암의 엔코더 신호를 통해서 컨트롤 박스는 사용자가 어떻게 로봇을 움직이고 있는지 실시간으로 확인이 가능하며, 프로그램에서 위치 정보를 반영시킨다.</p>

  <p class="txt indent1">많은 로봇은 리눅스 기반으로 개발 환경이 만들어져 있다. &#60;그림 I-6&#62; (b)와 같이 UR의 경우 Debian linux를 기반으로 ‘폴리스코프<span class="bracket">(Polyscope)</span>’라고 부르는 자체적인 OS를 제공한다. 폴리스코프는 크게 프로그래밍, 로봇 설정, 컨트롤 박스 환경 설정을 위한 메뉴를 가지고 있다. 화면 구성적인 측면에서는 상단부에 헤더를 ‘탭’ 형식으로 구현해 놓았다. 헤더의 탭을 선택하여 프로그래밍할지, 로봇의 설정 정보를 변경할지, 이동할지 등을 선택하는 식이다. 중간 부분에는 ‘프로그램 필드’가 있어서 헤더에서 선택한 탭에 따라서 세부 기능을 활용할 수 있다. 아래쪽으로 ‘푸터’가 있는데 이곳에는 로드된 프로그램의 실행, 구동 속도 제어 등이 가능하다. 이 푸터는 ‘헤더’에서 어떤 탭을 선택하더라도 바뀌지 않는다. 각 헤더 탭에 대한 구체적인 내용은 실습의 내용에 따라서 조금씩 나눠서 설명하도록 하겠다.</p>

  <div class="w60 img_center flex_column">
    <img alt="part01-p024-img" src="../Images/part01-p024-img.jpg"/> 

    <p class="imgcaption"><span class="gothic_b dblue">&#60;그림 Ⅰ-6&#62;</span> 티치 팬던트</p>
  </div>

  <h3 class="section gothic_b f115" id="sigil_toc_id_2"><span class="txtball dwhite">나</span> 폴리스코프</h3>

  <p class="본문_본문_동그라미-가_위치" lang="ko-KR"></p>

  <p class="txt indent1">폴리스코프는 UR에서 만든 협동로봇 제어용 OS이다. 이번 단원에서의 과제는 간단한 이동 동작의 프로그래밍이다. 이를 위해서 &#60;그림 I-7&#62;의 프로그램 탭에 대해서 먼저 간단히 설명하고자 한다. 나머지 구성 요소를 모두 설명하는 것은 상당한 시간이 필요하므로, 다음 단원으로 미루고자 한다. &#60;그림 I-7&#62; (a)는 폴리스코프 헤더에 있는 프로그램 탭을 눌렀을 때의 화면이다. ‘프로그램 필드’는 크게 3개 공간으로 나누어진다. 좌측 ① 공간은 폴리스코프에서 제공하는 ‘명령어’들이다. 미리 말해둘 것은 이 명령어들은 로봇 제어를 위한 모든 명령어를 포함하는 것은 아니다. 많은 협동로봇이 그러하지만 협동로봇은 고급 기술을 보유한 사용자보다는 일반적인 사용자에 초점을 맞추어 구성되어 있다. 즉, 일반 사용자들이 쉽게 프로그램할 수 있도록 많이 사용하는 명령어를 위주로 ‘블록코딩<span class="bracket">(Block Coding)</span>’ 형태로 프로그래밍하도록 구현되어 있다. 실제 고급 활용을 위해서는 이보다 훨씬 더 많은 명령어가 필요한데, 여기에 나타나지 않은 나머지 많은 명령어는 ‘텍스트’ 형태로 활용할 수 있다. UR에서는 이를 ‘UR 스크립트<span class="bracket">(UR Script)</span>’라고 부른다. 다만 초보 사용자들이 간단한 응용을 할 수 있는 것을 목적으로 하는 이 교재의 목적에 맞지 않아 다루지 않는다. &#60;그림 I-7&#62; (a) 를 자세히 살펴보자. ①에서 선택된 명령어는 ② 영역에 추가된다. 선택된 명령어들의 순서 조합에 따라서 로봇은 여러 동작을 하게 되는데, 전체적으로는 ‘로봇 프로그램’ 내부에 있는 트리 형식으로 표시된 명령어들이 순서대로 실행된다고 생각하면 된다. 그 우측인 ③ 영역에서는 ②에서 선택된 명령어의 세부 설정이 가능하다. 세부 설정 내용은 명령어마다 상이하므로 그때그때 설명하도록 하겠다. ③ 영역은 &#60;그림 I-7&#62; (b), (c), (d)와 같이 또다시 3개의 세부 탭으로 구성되어 있다. 각각 명령, 그래픽, 변수이다. ‘명령’ 탭에서는 해당 명령어에 대한 세부 설정이 가능하다. 예를 들어 &#60;그림 I-7&#62; (b)에서는 MoveJ의 세부 설정으로 사용하는 TCP<span class="bracket">(Tool Center Point)</span>, 특징, 속도의 사용자 설정이 가능하다. &#60;그림 I-7&#62; (c) ‘그래픽’ 탭에서는 사용자가 작성한 프로그램에 따른 로봇의 움직임이 그림으로 표시된다. 마지막 &#60;그림 I-7&#62; (d) ‘변수’ 탭에서는 현재 프로그램에서 활용되는 모든 변수의 값이 실시간으로 관찰할 수 있으며, 주로 디버깅<span class="bracket">(Debugging)</span>에 효과적으로 사용할 수 있다.</p>

  <div class="w100 img_center ">
    <img alt="part01-p026-img1" src="../Images/part01-p026-img1.jpg"/>
  </div>

  <div class="w100 img_center ">
    <img alt="part01-p026-img2" src="../Images/part01-p026-img2.jpg"/>
  </div>

  <div class="w100 img_center ">
    <img alt="part01-p027-img1" src="../Images/part01-p027-img1.jpg"/>
  </div>

  <div class="w100 img_center flex_column">
    <img alt="part01-p027-img2" src="../Images/part01-p027-img2.jpg"/> 

    <p class="imgcaption"><span class="gothic_b dblue">&#60;그림 Ⅰ-7&#62;</span> 프로그램 탭</p>
  </div>

  <h3 class="section gothic_b f115" id="sigil_toc_id_3"><span class="txtball dwhite">다</span> 이동 명령어</h3>

  <p class="th4">1) 이동 동작의 종류</p>

  <p class="txt indent1">‘프로그램 탭-기본-이동’을 선택하면 &#60;그림 I-6&#62;과 같이 ‘MoveJ’ 및 ‘웨이포인트’가 프로그램에 추가된다. &#60;그림 I-8&#62;에서 표시된 것과 같이 우측 상단의 ‘MoveJ’를 선택하면 아래로 세 가지 이동 동작 종류를 선택할 수 있으며, 각각 MoveJ, MoveL, MoveP이다. 로봇 동작의 대부분 절반 이상이 이 ‘이동’ 동작을 실행하는 데 사용된다. 그래서, 적절한 이동 방법을 선택하여 사용하는 것은 매우 중요하다. 이것은 동작에 있어서 주변 장치와의 충돌 등을 막는 것뿐만 아니라, 동작 자체의 최적화, 전력적인 측면에서 효율적인 운용, 모터의 수명 등에도 직간접적으로 연관이 있다. 로봇이 24시간 반복적 동작을 목표한다는 점에서 그 중요성은 다시 한번 생각할 필요가 있다. 각 이동 동작의 특징에 대해서는 아래에 구체적으로 설명하겠다.</p>

  <div class="w100 img_center flex_column">
    <img alt="part01-p028-img" src="../Images/part01-p028-img.jpg"/> 

    <p class="imgcaption"><span class="gothic_b dblue">&#60;그림 Ⅰ-8&#62;</span> 이동 명령어의 선택 메뉴</p>
  </div>

  <p class="th4">2) MoveJ</p>

  <p class="txt indent1">MoveJ는 ‘Joint Movement’라고 한다. &#60;그림 I-9&#62;는 MoveJ의 이동 경로의 모습이며, 두 지점을 움직일 때 호를 그리면서 움직이는 것을 알 수 있다. 이 동작은 쉽게 설명하자면 사람의 손을 무의식적으로 두 지점으로 이동할 때를 생각하면 쉽게 이해할 수 있다. 이 경우 손은 가장 근육 운동을 최소화하는 경로를 따라 이동하게 되는데, 이 경로는 직선이 아니다. 이는 신체의 구조상 ‘뼈’라는 고정체를 근육을 이용하여 움직이는 상황에서 직선 움직임은 어깨를 포함한 많은 근육이 동시에 움직여야 해서 효율적이지 못하게 된다. 오히려 손 자체가 움직이는 경로 자체가 더 길어지더라도 적절한 호를 그리면서 움직이는 것이 근육 활용을 최소화할 수 있다. 즉, 에너지 측면에서 효율적인 것이다. 로봇도 마찬가지로 6개의 모터 사이에 7개 정도의 고정체로 이루어져 있으므로 사람의 신체와 크게 다르지 않다. 목표 위치로 이동하였을 때의 각 모터의 최종 위치가 있고 그 모터들이 동시에 그렇게 움직였을 때 만들어지는 궤적이 곡선을 나타내게 되는 것이다. 두 점을 직선으로 움직이는 동작보다 에너지 효율적일 수밖에 없으며, 모터가 제한된 각속도를 가질 때 다른 어떤 이동 명령보다 요구 시간 측면에서도 효율적이다. 이러한 이유로 MoveJ 명령은 대부분의 신속한 이동이 필요한 경우에 적절하며, 이동의 기본 동작으로 설정되어 있다. 하지만 단점으로는 이동 경로가 불분명하므로 이동하는 두 지점 사이에 방해물이 없는지는 반드시 확인해야 한다. 이러한 이유로 이동을 구현할 때는 제일 먼저 MoveJ를 사용하여도 되는지를 고려하는 것이 현명하다.</p>

  <div class="w80 img_center flex_column">
    <img alt="part01-p029-img" src="../Images/part01-p029-img.jpg"/> 

    <p class="imgcaption"><span class="gothic_b dblue">&#60;그림 Ⅰ-9&#62;</span>MoveJ 동작의 이동 경로 특성</p>
  </div>

  <p class="th4">3) MoveL</p>

  <p class="txt indent1">&#60;그림 I-10&#62;은 MoveL의 이동 경로의 모습이다. MoveL는 ‘Linear Movement’라고 한다. 앞서 설명한 MoveJ는 이동 과정의 속도 및 에너지 측면에서 효율적인 반면, ‘이동 경로’가 불분명한 한계가 있다. 실제 현장에서 사용하는 경우 다양한 방해물이 존재하는 많은 경우가 발생한다. 예를 들어 기구물 가공을 위한 CNC 머신을 사용할 때를 가정해 보자. 이때 로봇은 가공 재료를 로딩<span class="bracket">(loading)</span>하거나 혹은 가공된 제품을 빼내는 과정에서 장치의 내부 좁은 공간을 주변 물체와 충돌 없이 움직여야 한다. 이때 MoveL은 지정된 두 지점을 ‘직선’이라는 예측할 수 있는 경로로 이동시킬 수 있으므로 사용자는 확정적으로 충돌을 회피하는 움직임을 구현할 수 있게 된다. 정리하자면, MoveL은 이동 과정에서 충돌 등이 예상될 때, 사용자가 확정적인 경로로 이동시키는 경우 사용되어야 한다.</p>

  <p class="txt indent1">간혹 MoveJ로 이동할 수 있었던 경로의 프로그램이 MoveL에서는 불가능할 경우가 발생한다. 이는 그 이동 구간 사이의 특정 지점이 로봇의 도달할 수 없는 영역에 들어가기도 한다. 이런 로봇이 동작 불가능한 영역 혹은 지점을 ‘특이점’이라고 한다. 이 경우 웨이포인트 변경을 통해서 적절한 이동 경로를 새로 만들어주어야 한다.</p>

  <div class="w80 img_center flex_column">
    <img alt="part01-p030-img" src="../Images/part01-p030-img.jpg"/> 

    <p class="imgcaption"><span class="gothic_b dblue">&#60;그림 Ⅰ-10&#62;</span> MoveL 동작의 이동 경로 특성</p>
  </div>

  <div class="tip_icon"></div>

  <div class="tipbox">
    <p class="txt gothic_m">산업용 다관절 로봇은 여러 개의 관절을 가진 기계팔로서, 다양한 작업을 수행할 수 있다. 하지만 이러한 로 봇의 이동에는 ‘특이점’이라는 문제가 있다. 특이점이란 로봇의 관절이 일정한 각도로 정렬되어서 로봇의 자유도가 감소하거나 손실되는 상황을 이야기한다. 예를 들어, 로봇의 팔이 일직선으로 뻗어 있으면 어느 방향으로도 움직일 수 없는 특이점에 빠지게 된다. 특이점에 빠지면 로봇은 제어가 어려워지고 작업 효율이 떨어지며, 심한 경우에는 로봇의 손상이나 사고의 위험이 증가한다. 따라서 산업용 다관절 로봇의 이동에 서는 특이점을 회피하거나 해결하는 방법이 필요하다.</p>
  </div>

  <p class="th4">4) MoveP</p>

  <p class="txt indent1">MoveP는 ‘Process Movement’라고 한다. 용접을 생각하면 쉬운데, 가령 로봇 끝단에 용접봉이 달려있다고 생각을 해 보자. 용접에서 중요한 것은 용접하는 시간을 동일하게 유지하는 것이다. 이 시간이 유지되지 못하면 과용접 내지는 용접이 안 되는 상황을 예상할 수 있다. 이러한 용도로 MoveP가 사용될 수 있는데, 핵심은 이동 동작 동안 ‘속도’를 유지해 준다는 점이다. &#60;그림 I-11&#62;은 세 지점을 MoveP를 사용하여 움직이는 예이다. 여기서 이 이동 명령어의 독특한 특징을 발견할 수 있는데, 바로 웨이포인트를 지나지 않고 호를 그리면서 움직인다는 점이다. 꼭짓점이 있다는 것은 물리적으로 보자면 반드시 ‘정지’ 지점이 발생하게 된다. 즉, 속도의 변화가 생기는 것이다. MoveP는 ‘속도’를 유지하기 위해서 사용자의 설정에 따라서 적절한 회전 경로를 만든다.</p>

  <p class="txt indent1">MoveP를 사용할 때의 주의점이 있다. 너무 예리한 각의 이동 경로에 MoveP를 사용하게 되면 특정 모터가 움직일 수 있는 한계 속도를 넘어가게 되어 에러를 발생시킨다는 점이다. 에러가 발생하지 않더라도 기구적으로 지속적인 충격을 줄 수 있는 동작은 지양하는 것이 좋겠다. 또한 MoveP 역시 웨이포인트 사이의 이동은 직선의 움직임이므로 MoveL과 같이 특이점 문제가 존재한다.</p>

  <div class="w80 img_center flex_column">
    <img alt="part01-p031-img" src="../Images/part01-p031-img.jpg"/>
  </div>

  <p class="imgcaption"><span class="gothic_b dblue">&#60;그림 Ⅰ-11&#62;</span> MoveP 동작의 특성</p>

  <p class="txt indent1">이 외에 MoveC가 있다. 원<span class="bracket">(circle)</span> 동작을 구현하는 특별한 명령어로 두 지점 및 원 경로상의 한 점을 추가하여 구현할 수 있다. UR 로봇의 경우 MoveP의 세부 설정을 변경하여 구현할 수 있다.</p>
</body>
</html>